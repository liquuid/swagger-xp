github repo used to drive some tests:  https://github.com/liquuid/swagger-xp

Tested in Swagger 2.2.3

Swagger has three main components: 

Swagger Editor (https://editor.swagger.io/) is probably the easiest way to edit OpenAPI specification. All you need is a browser and there’s no need to sign up for an account. It has been rewritten from the ground up.

Swagger UI, generate a beautiful interface for API and its documentation.

Swagger Codegen, a client/server generator for more than 60 languages,

Main develop approach
---------------------

1) Design API first ( Contract First )

    * Write specification first
    * Generate server
    * Generate SDK proxy to client

    * Parallelize back end and front end
    * Changes in contract can be versionate

2) Legacy API

    * Document an existent API
    * Build a Contract
    * Validation
    * Results in documented API and SDK clients

3) Service driven

    * The service defines the Contract
    * The API specification can be generated assisted by a reflection library
    * Needs attention to don't break the API compatibility


Instead of using the contract-first approach to write the specification manually, there are plugins that can generate OpenAPI/Swagger specification from the API server’s source code so that the source code is always in sync with the specification. Here are a few examples:


* Swashbuckle (https://github.com/domaindrivendev/Swashbuckle): Seamlessly adds a Swagger/OpenAPI to C# WebApi projects.

* swagger-inline (https://github.com/readmeio/swagger-inline) by ReadMe 36 : Writes your swagger file as comments.

* transmute-core (http://transmute-core.readthedocs.io/en/latest/): Converts Python
functions into APIs that include OpenAPI/Swagger 2.0 schema validation and documentation.

* ruby-grape (https://github.com/ruby-grape/grape-swagger): Allows you to generate OpenAPI/Swagger 2.0 specifications from Grape APIs.

* swagger-jsdoc (https://www.npmjs.com/package/swagger-jsdoc): Keeps an up-to-date and reusable OpenAPI/Swagger 2.0 specification through documentation in the code.


API Versioning
-----------

* In URL :   

            GET /v1/{...}?param=AAA            
            GET /v2/{...}?param=BBB&param2=CCC

* In parameter: 

             GET /{...}?param=AAA&v=2

* In Header:

            GET /{...}?param=AAA
            Version: 2



Generators
----------
    java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate 
        -c config.json 
        -i swagger.yaml 
        -l go-server 
        -t go-server-template -o /tmp/go-server


Customizing the autogenerated code
----------------------------------

For language-specific options, we need to use the “-l” command line switch with “config-
help”. Here is an example:
    
    $ java -jar swagger-codegen-cli.jar config-help -l python

For Python API client generator, there are 5 options available at the moment while other
generators may have more.

Customization using the templates
---------------------------------

Swagger Code-gen CLI comes with the following option to provide customized templates:

    -t <template directory>, --template-dir <template directory>
        folder containing the template files

The default templates can be obtained from the Swagger Codegen Github repository under
the “modules/swagger-codegen/src/main/resources” folder.

The file “api_info.mustache” is what we call a partial in mustache, which is just another
mustache template and it is imported by other files.

That way we can reuse common texts or codes among other files. 



Modifying the client library format
-----------------------------------

Don't like the default swagger client syntax? Want a different language supported? No problem! Swagger code-gen processes mustache templates with the [jmustache](https://github.com/samskivert/jmustache) engine. You can modify our templates or make your own.

You can look at modules/swagger-codegen/src/main/resources/${your-language} for examples. To make your own templates, create your own files and use the -t flag to specify your template folder. It actually is that easy.
Making your own codegen modules

If you're starting a project with a new language and don't see what you need, swagger-codegen can help you create a project to generate your own libraries:

    java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar
            meta  -o output/myLibrary -n myClientCodegen -p com.my.company.codegen

This will write, in the folder output/myLibrary, all the files you need to get started, including a README.md. Once modified and compiled, you can load your library with the codegen and generate clients with your own, custom-rolled logic.

You would then compile your library in the output/myLibrary folder with mvn package and execute the codegen like such:

    java -cp  output/myLibrary/target/myClientCodegen-swagger-codegen-1.0.0.jar:module
      s/swagger-codegen-cli/target/swagger-codegen-cli.jar
      io.swagger.codegen.SwaggerCodegen


Note the myClientCodegen is an option now, and you can use the usual arguments for generating your library:

    java -cp output/myLibrary/target/myClientCodegen-swagger-codegen-1.0.0.jar:modules/swagger-codegen-cli/target/swagger-codegen-cli.jar
        io.swagger.codegen.SwaggerCodegen generate -l myClientCodegen
        -i swagger.json
        -o myClient



Generating a client from local files
------------------------------------

If you don't want to call your server, you can save the OpenAPI Spec files into a directory and pass an argument to the code generator like this:

    -i ./swagger.json

Great for creating libraries on your ci server, from the Swagger Editor... or while coding on an airplane.
Selective generation

You may not want to generate all models in your project. Likewise you may want just one or two apis to be written. If that's the case, you can use system properties to control the output:

The default is generate everything supported by the specific library. Once you enable a feature, it will restrict the contents generated:

    # generate only models
    java -Dmodels {opts}

    # generate only apis
    java -Dapis {opts}

    # generate only supporting files
    java -DsupportingFiles

    # generate models and supporting files
    java -Dmodels -DsupportingFiles

To control the specific files being generated, you can pass a CSV list of what you want:

    # generate the User and Pet models only
    -Dmodels=User,Pet

    # generate the User model and the supportingFile `StringUtil.java`:
    -Dmodels=User -DsupportingFiles=StringUtil.java

To control generation of docs and tests for api and models, pass false to the option. For api, these options are `-DapiTests=false` and   `-DapiDocs=false`. For models, `-DmodelTests=false` and `-DmodelDocs=false`. These options default to true and don't limit the generation of the feature options listed above (like -Dapi):

    # generate only models (with tests and documentation)
    java -Dmodels {opts}

    # generate only models (with tests but no documentation)
    java -Dmodels -DmodelDocs=false {opts}

    # generate only User and Pet models (no tests and no documentation)
    java -Dmodels=User,Pet -DmodelTests=false {opts}

    # generate only apis (without tests)
    java -Dapis -DapiTests=false {opts}

    # generate only apis (modelTests option is ignored)
    java -Dapis -DmodelTests=false {opts}

When using selective generation, only the templates needed for the specific generation will be used.

Ignore file format
------------------

Swagger code-gen supports a `.swagger-codegen-ignore` file, similar to  `.gitignore` or `.dockerignore` you're probably already familiar with.

The ignore file allows for better control over overwriting existing files than the `--skip-overwrite` flag. With the ignore file, you can specify individual files or directories can be ignored. This can be useful, for example if you only want a subset of the generated code.

Examples:

    # Swagger Codegen Ignore
    # Lines beginning with a # are comments

    # This should match build.sh located anywhere.
    build.sh

    # Matches build.sh in the root
    /build.sh

    # Exclude all recursively
    docs/**

    # Explicitly allow files excluded by other rules
    !docs/UserApi.md

    # Recursively exclude directories named Api
    # You can't negate files below this directory.
    src/**/Api/

    # When this file is nested under /Api (excluded above),
    # this rule is ignored because parent directory is excluded by previous rule.
    !src/**/PetApiTests.cs

    # Exclude a single, nested file explicitly
    src/IO.Swagger.Test/Model/AnimalFarmTests.cs

The `.swagger-codegen-ignore` file must exist in the root of the output directory.

Upon first code generation, you may also pass the CLI option `--ignore-file-override=/path/to/ignore_file` for greater control over generated outputs. Note that this is a complete override, and will override the `.swagger-codegen-ignore` file in an output directory when regenerating code.

Editor support for `.swagger-codegen-ignore` files is available in IntelliJ via the `.ignore` plugin.

Customizing the generator
-------------------------

There are different aspects of customizing the code generator beyond just creating or modifying templates. Each language has a supporting configuration file to handle different type mappings, etc:

    $ ls -1 modules/swagger-codegen/src/main/java/io/swagger/codegen/languages/
    AbstractJavaJAXRSServerCodegen.java
    AbstractTypeScriptClientCodegen.java
    ... (results omitted)
    TypeScriptAngularClientCodegen.java
    TypeScriptNodeClientCodegen.java

Each of these files creates reasonable defaults so you can get running quickly. But if you want to configure package names, prefixes, model folders, etc. you can use a json config file to pass the values.

    java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate
    -i swagger.json 
    -l java 
    -o samples/client/petstore/java 
    -c path/to/config.json

and config.json contains the following as an example:

    {
    "apiPackage" : "petstore"
    }

Supported config options can be different per language. Running `config-help -l {lang}` will show available options.
These options are applied via configuration file (e.g. config.json) or by passing them with `-D{optionName}={optionValue}`. (If `-D{optionName}` does not work, please open a ticket and we'll look into it)

    java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar config-help -l java

Output

    CONFIG OPTIONS
        modelPackage
            package for generated models

        apiPackage
            package for generated api classes
    ...... (results omitted)
        library
            library template (sub-template) to use:
            jersey1 - HTTP client: Jersey client 1.18. JSON processing: Jackson 2.4.2
            jersey2 - HTTP client: Jersey client 2.6
            feign - HTTP client: Netflix Feign 8.1.1.  JSON processing: Jackson 2.6.3
            okhttp-gson (default) - HTTP client: OkHttp 2.4.0. JSON processing: Gson 2.3.1
            retrofit - HTTP client: OkHttp 2.4.0. JSON processing: Gson 2.3.1 (Retrofit 1.9.0)
            retrofit2 - HTTP client: OkHttp 2.5.0. JSON processing: Gson 2.4 (Retrofit 2.0.0-beta2)
            google-api-client - HTTP client: google-api-client 1.23.0. JSON processing: Jackson 2.8.9

Your config file for Java can look like

    {
    "groupId":"com.my.company",
    "artifactId":"MyClient",
    "artifactVersion":"1.2.0",
    "library":"feign"
    }

For all the unspecified options default values will be used.

Another way to override default options is to extend the config class for the specific language. To change, for example, the prefix for the Objective-C generated files, simply subclass the ObjcClientCodegen.java:

    package com.mycompany.swagger.codegen;

    import io.swagger.codegen.languages.*;

    public class MyObjcCodegen extends ObjcClientCodegen {
        static {
            PREFIX = "HELO";
        }
    }

and specify the classname when running the generator:

    -l com.mycompany.swagger.codegen.MyObjcCodegen

Your subclass will now be loaded and overrides the PREFIX value in the superclass.

Bringing your own models
------------------------

Sometimes you don't want a model generated. In this case, you can simply specify an import mapping to tell the codegen what not to create. When doing this, every location that references a specific model will refer back to your classes. Note, this may not apply to all languages...

To specify an import mapping, use the `--import-mappings` argument and specify the model-to-import logic as such:

    --import-mappings Pet=my.models.MyPet

Or for multiple mappings:

    --import-mappings Pet=my.models.MyPet,Order=my.models.MyOrder

or

    --import-mappings Pet=my.models.MyPet --import-mappings Order=my.models.MyOrder


Go-Swagger ( https://goswagger.io/ ) 
------------------------------------

Saddly the oficial swagger-codegen generator is not good enough for golang.

The swagger-codegen project only generates a client and even there it will only support flat models.

* Go-Swagger project supports most features offered by jsonschema including polymorphism.
* It allows for generating a swagger specification from go code.
* It allows for generating a server from a swagger definition and to generate an equivalent spec back from that codebase.
* It allows for generating a client from a swagger definition.
* It has support for several common swagger vendor extensions.

To start we define a swagger.yml specification file: 

    ---
    swagger: "2.0"
    info:
    description: The product of a tutorial on goswagger.io
    title: A To Do list application
    version: 1.0.0
    consumes:
    - application/io.goswagger.examples.todo-list.v1+json
    produces:
    - application/io.goswagger.examples.todo-list.v1+json
    schemes:
    - http
    - https
    paths:
    /:
        get:
        tags:
            - todos
        parameters:
            - name: since
            in: query
            type: integer
            format: int64
            - name: limit
            in: query
            type: integer
            format: int32
            default: 20
        responses:
            200:
            description: list the todo operations
            schema:
                type: array
                items:
                $ref: "#/definitions/item"
            default:
            description: generic error response
            schema:
                $ref: "#/definitions/error"
    definitions:
    item:
        type: object
        required:
        - description
        properties:
        id:
            type: integer
            format: int64
            readOnly: true
        description:
            type: string
            minLength: 1
        completed:
            type: boolean
    error:
        type: object
        required:
        - message
        properties:
        code:
            type: integer
            format: int64
        message:
            type: string


We must validade our specification with:

    swagger validate ./swagger.yml

To generate a server we use this:

    swagger generate server -A TodoList -f ./swagger.yml

In this file tree you notice that there is a cmd/todo-list-server generated. The swagger generator adds -server to the application name (provided to the generated command through the -A argument).

The second major section in this tree is the models package. This package contains go representations for both the defintions from the swagger spec document.

And then the last major section is the rest api, within the rest api there is the code that is generated based on the information from the paths property in the swagger specification. The go swagger generator uses the tags to group the operations into packages.

To build the binary and then run it:

    go install ./cmd/todo-list-server/
    todo-list-server





References:
--
https://www.slideshare.net/pjmolina/diseo-de-apis-con-openapi

https://github.com/swagger-api/swagger-codegen#generators

https://www.jcore.com/2017/05/22/automatically-generating-api-using-swagger-and-gradle/

https://www.youtube.com/watch?v=EzKwi-u9jQo

https://github.com/go-swagger/go-swagger